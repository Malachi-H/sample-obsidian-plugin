import ObservableSlim from "observable-slim";
/**
 *  Wrapper class to make any object/primitive observable
 */
export class State {
    constructor(value) {
        this.listeners = new Map();
        this.onChange = (callback) => {
            const listenerId = this.generateListenerId();
            this.listeners.set(listenerId, callback);
            return () => this.unsubscribe(listenerId); // return unsubscribe function
        };
        this.generateListenerId = () => {
            State.listener_count++;
            return State.listener_count;
        };
        this.unsubscribe = (listenerId) => {
            this.listeners.delete(listenerId);
        };
        this.notifyAll = (changeData) => {
            this.listeners.forEach((listener) => listener(changeData));
        };
        this.onValueChange = (changes) => {
            changes.forEach((change) => {
                this.notifyAll(Object.assign({}, change, { triggerStateId: this.id }));
            });
        };
        State.stateCount++;
        this.id = State.stateCount;
        this.val =
            typeof value === "object" ? ObservableSlim.create(value, false, this.onValueChange) : value;
    }
    get value() {
        return this.val;
    }
    set value(val) {
        const previousValue = this.val;
        if (typeof val !== "object") {
            this.val = val;
        }
        else {
            this.val = ObservableSlim.create(val, false, this.onValueChange);
        }
        this.onValueChange([
            {
                type: "update",
                property: "",
                currentPath: "",
                jsonPointer: "",
                target: this.val,
                // @ts-ignore
                proxy: this.val.__getProxy,
                previousValue,
                newValue: this.val,
            },
        ]);
    }
    /**
     * create a substate of this state.
     *
     * @remarks You cannot create a substate for a primitive type state.
     */
    createSubState(key) {
        const subStateKeys = key.split(".");
        const subStateValue = subStateKeys.reduce((obj, key) => {
            const val = obj[key];
            if (val !== undefined) {
                return val;
            }
            throw new InvalidStateKeyError(key, this);
        }, this);
        // if this is a primitive type, we cannot create a substate
        if (typeof subStateValue !== "object") {
            throw new Error("SubStates of properties that are Primitives are not supported yet.");
        }
        // @ts-ignore
        return new State(subStateValue === null || subStateValue === void 0 ? void 0 : subStateValue.__getTarget);
        // if (typeof subStateValue === "object" && type) {
        //   // check if is like generic type S
        //   // ts-ignore
        //   return new State(subStateValue?.__getTarget);
        // } else throw new Error("SubStates of properties that are Primitives are not supported yet.");
    }
    getRawValue() {
        if (typeof this.val === "object") {
            // @ts-ignore
            return this.val.__getTarget;
        }
        return this.val;
    }
}
State.listener_count = 0;
State.stateCount = 0;
// custom error type for invalid state keys
export class InvalidStateKeyError extends Error {
    constructor(subStateKey, state) {
        super();
        this.message = `Key does not exist!
    Detailed error:
    "${subStateKey}" could not be found in {"value":${JSON.stringify(state.value)}}
    `;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiU3RhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJTdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLGNBQWMsTUFBTSxpQkFBaUIsQ0FBQztBQVU3Qzs7R0FFRztBQUNILE1BQU0sT0FBTyxLQUFLO0lBUWhCLFlBQVksS0FBUTtRQVBILGNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBeUIsQ0FBQztRQXlDdkQsYUFBUSxHQUFHLENBQUMsUUFBdUMsRUFBZ0IsRUFBRTtZQUMxRSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztZQUM3QyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDekMsT0FBTyxHQUFHLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsOEJBQThCO1FBQzNFLENBQUMsQ0FBQztRQXlDTSx1QkFBa0IsR0FBRyxHQUFHLEVBQUU7WUFDaEMsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3ZCLE9BQU8sS0FBSyxDQUFDLGNBQWMsQ0FBQztRQUM5QixDQUFDLENBQUM7UUFFTSxnQkFBVyxHQUFHLENBQUMsVUFBa0IsRUFBRSxFQUFFO1lBQzNDLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ3BDLENBQUMsQ0FBQztRQUVNLGNBQVMsR0FBRyxDQUFDLFVBQXVCLEVBQUUsRUFBRTtZQUM5QyxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7UUFDN0QsQ0FBQyxDQUFDO1FBRU0sa0JBQWEsR0FBRyxDQUFDLE9BQXNCLEVBQUUsRUFBRTtZQUNqRCxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxFQUFFLEVBQUU7Z0JBQ3pCLElBQUksQ0FBQyxT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LEtBQUs7SUFDaEQsWUFBWSxXQUFtQixFQUFFLEtBQWU7UUFDOUMsS0FBSyxFQUFFLENBQUM7UUFDUixJQUFJLENBQUMsT0FBTyxHQUFHOztPQUVaLFdBQVcsb0NBQW9DLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztLQUM1RSxDQUFDO0lBQ0osQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IE9ic2VydmFibGVTbGltIGZyb20gXCJvYnNlcnZhYmxlLXNsaW1cIjtcclxuXHJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAvL1xyXG4vLyA9PT09PT09PT09PT09PT09PT09PT09IFN0YXRlID09PT09PT09PT09PT09PT09PT09PT0gLy9cclxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09IC8vXHJcblxyXG4vLyBXcmFwcGVyIGNsYXNzIHRvIG1ha2UgYW55IG9iamVjdC9wcmltaXRpdmUgb2JzZXJ2YWJsZVxyXG5cclxuZXhwb3J0IHR5cGUgU3RhdGVMaXN0ZW5lciA9IChjaGFuZ2VEYXRhOiBTdGF0ZUNoYW5nZSkgPT4gdm9pZDtcclxuXHJcbi8qKlxyXG4gKiAgV3JhcHBlciBjbGFzcyB0byBtYWtlIGFueSBvYmplY3QvcHJpbWl0aXZlIG9ic2VydmFibGVcclxuICovXHJcbmV4cG9ydCBjbGFzcyBTdGF0ZTxUPiB7XHJcbiAgcHJpdmF0ZSByZWFkb25seSBsaXN0ZW5lcnMgPSBuZXcgTWFwPG51bWJlciwgU3RhdGVMaXN0ZW5lcj4oKTtcclxuICBwcml2YXRlIHN0YXRpYyBsaXN0ZW5lcl9jb3VudCA9IDA7XHJcblxyXG4gIHByaXZhdGUgdmFsOiBQcm94eUNvbnN0cnVjdG9yIHwgVDtcclxuICBwcml2YXRlIHN0YXRpYyBzdGF0ZUNvdW50ID0gMDtcclxuICByZWFkb25seSBpZDogbnVtYmVyO1xyXG5cclxuICBjb25zdHJ1Y3Rvcih2YWx1ZTogVCkge1xyXG4gICAgU3RhdGUuc3RhdGVDb3VudCsrO1xyXG4gICAgdGhpcy5pZCA9IFN0YXRlLnN0YXRlQ291bnQ7XHJcblxyXG4gICAgdGhpcy52YWwgPVxyXG4gICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgPyBPYnNlcnZhYmxlU2xpbS5jcmVhdGUodmFsdWUsIGZhbHNlLCB0aGlzLm9uVmFsdWVDaGFuZ2UpIDogdmFsdWU7XHJcbiAgfVxyXG5cclxuICBnZXQgdmFsdWUoKTogVCB7XHJcbiAgICByZXR1cm4gdGhpcy52YWwgYXMgVDtcclxuICB9XHJcblxyXG4gIHNldCB2YWx1ZSh2YWw6IFQpIHtcclxuICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0aGlzLnZhbDtcclxuICAgIGlmICh0eXBlb2YgdmFsICE9PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgIHRoaXMudmFsID0gdmFsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy52YWwgPSBPYnNlcnZhYmxlU2xpbS5jcmVhdGUodmFsLCBmYWxzZSwgdGhpcy5vblZhbHVlQ2hhbmdlKTtcclxuICAgIH1cclxuICAgIHRoaXMub25WYWx1ZUNoYW5nZShbXHJcbiAgICAgIHtcclxuICAgICAgICB0eXBlOiBcInVwZGF0ZVwiLFxyXG4gICAgICAgIHByb3BlcnR5OiBcIlwiLFxyXG4gICAgICAgIGN1cnJlbnRQYXRoOiBcIlwiLFxyXG4gICAgICAgIGpzb25Qb2ludGVyOiBcIlwiLFxyXG4gICAgICAgIHRhcmdldDogdGhpcy52YWwsXHJcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICAgIHByb3h5OiAodGhpcy52YWwgYXMgbmV2ZXIpLl9fZ2V0UHJveHksXHJcbiAgICAgICAgcHJldmlvdXNWYWx1ZSxcclxuICAgICAgICBuZXdWYWx1ZTogdGhpcy52YWwsXHJcbiAgICAgIH0sXHJcbiAgICBdKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBvbkNoYW5nZSA9IChjYWxsYmFjazogKGNoYW5nZTogU3RhdGVDaGFuZ2UpID0+IHZvaWQpOiAoKCkgPT4gdm9pZCkgPT4ge1xyXG4gICAgY29uc3QgbGlzdGVuZXJJZCA9IHRoaXMuZ2VuZXJhdGVMaXN0ZW5lcklkKCk7XHJcbiAgICB0aGlzLmxpc3RlbmVycy5zZXQobGlzdGVuZXJJZCwgY2FsbGJhY2spO1xyXG4gICAgcmV0dXJuICgpID0+IHRoaXMudW5zdWJzY3JpYmUobGlzdGVuZXJJZCk7IC8vIHJldHVybiB1bnN1YnNjcmliZSBmdW5jdGlvblxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIGNyZWF0ZSBhIHN1YnN0YXRlIG9mIHRoaXMgc3RhdGUuXHJcbiAgICpcclxuICAgKiBAcmVtYXJrcyBZb3UgY2Fubm90IGNyZWF0ZSBhIHN1YnN0YXRlIGZvciBhIHByaW1pdGl2ZSB0eXBlIHN0YXRlLlxyXG4gICAqL1xyXG4gIHB1YmxpYyBjcmVhdGVTdWJTdGF0ZTxTPihrZXk6IFQgZXh0ZW5kcyBvYmplY3QgPyBgdmFsdWUuJHtOZXN0ZWRLZXlvZjxUPn1gIDogc3RyaW5nKTogU3RhdGU8Uz4ge1xyXG4gICAgY29uc3Qgc3ViU3RhdGVLZXlzID0ga2V5LnNwbGl0KFwiLlwiKTtcclxuICAgIGNvbnN0IHN1YlN0YXRlVmFsdWU6IFMgPSBzdWJTdGF0ZUtleXMucmVkdWNlKChvYmo6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LCBrZXk6IHN0cmluZykgPT4ge1xyXG4gICAgICBjb25zdCB2YWwgPSBvYmpba2V5XTtcclxuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCBhcyBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPjtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFN0YXRlS2V5RXJyb3Ioa2V5LCB0aGlzKTtcclxuICAgIH0sIHRoaXMgYXMgUmVjb3JkPHN0cmluZywgdW5rbm93bj4pIGFzIFM7XHJcblxyXG4gICAgLy8gaWYgdGhpcyBpcyBhIHByaW1pdGl2ZSB0eXBlLCB3ZSBjYW5ub3QgY3JlYXRlIGEgc3Vic3RhdGVcclxuICAgIGlmICh0eXBlb2Ygc3ViU3RhdGVWYWx1ZSAhPT0gXCJvYmplY3RcIikge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdWJTdGF0ZXMgb2YgcHJvcGVydGllcyB0aGF0IGFyZSBQcmltaXRpdmVzIGFyZSBub3Qgc3VwcG9ydGVkIHlldC5cIik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgcmV0dXJuIG5ldyBTdGF0ZShzdWJTdGF0ZVZhbHVlPy5fX2dldFRhcmdldCk7XHJcblxyXG4gICAgLy8gaWYgKHR5cGVvZiBzdWJTdGF0ZVZhbHVlID09PSBcIm9iamVjdFwiICYmIHR5cGUpIHtcclxuICAgIC8vICAgLy8gY2hlY2sgaWYgaXMgbGlrZSBnZW5lcmljIHR5cGUgU1xyXG5cclxuICAgIC8vICAgLy8gdHMtaWdub3JlXHJcbiAgICAvLyAgIHJldHVybiBuZXcgU3RhdGUoc3ViU3RhdGVWYWx1ZT8uX19nZXRUYXJnZXQpO1xyXG4gICAgLy8gfSBlbHNlIHRocm93IG5ldyBFcnJvcihcIlN1YlN0YXRlcyBvZiBwcm9wZXJ0aWVzIHRoYXQgYXJlIFByaW1pdGl2ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcclxuICB9XHJcblxyXG4gIHB1YmxpYyBnZXRSYXdWYWx1ZSgpOiBUIHtcclxuICAgIGlmICh0eXBlb2YgdGhpcy52YWwgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgLy8gQHRzLWlnbm9yZVxyXG4gICAgICByZXR1cm4gKHRoaXMudmFsIGFzIHVua25vd24gYXMgUHJveHlDb25zdHJ1Y3RvcikuX19nZXRUYXJnZXQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdGhpcy52YWwgYXMgVDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2VuZXJhdGVMaXN0ZW5lcklkID0gKCkgPT4ge1xyXG4gICAgU3RhdGUubGlzdGVuZXJfY291bnQrKztcclxuICAgIHJldHVybiBTdGF0ZS5saXN0ZW5lcl9jb3VudDtcclxuICB9O1xyXG5cclxuICBwcml2YXRlIHVuc3Vic2NyaWJlID0gKGxpc3RlbmVySWQ6IG51bWJlcikgPT4ge1xyXG4gICAgdGhpcy5saXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVySWQpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgbm90aWZ5QWxsID0gKGNoYW5nZURhdGE6IFN0YXRlQ2hhbmdlKSA9PiB7XHJcbiAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbGlzdGVuZXIoY2hhbmdlRGF0YSkpO1xyXG4gIH07XHJcblxyXG4gIHByaXZhdGUgb25WYWx1ZUNoYW5nZSA9IChjaGFuZ2VzOiBTdGF0ZUNoYW5nZVtdKSA9PiB7XHJcbiAgICBjaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xyXG4gICAgICB0aGlzLm5vdGlmeUFsbChPYmplY3QuYXNzaWduKHt9LCBjaGFuZ2UsIHsgdHJpZ2dlclN0YXRlSWQ6IHRoaXMuaWQgfSkpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxufVxyXG5cclxuLy8gY3VzdG9tIGVycm9yIHR5cGUgZm9yIGludmFsaWQgc3RhdGUga2V5c1xyXG5leHBvcnQgY2xhc3MgSW52YWxpZFN0YXRlS2V5RXJyb3I8VD4gZXh0ZW5kcyBFcnJvciB7XHJcbiAgY29uc3RydWN0b3Ioc3ViU3RhdGVLZXk6IHN0cmluZywgc3RhdGU6IFN0YXRlPFQ+KSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5tZXNzYWdlID0gYEtleSBkb2VzIG5vdCBleGlzdCFcclxuICAgIERldGFpbGVkIGVycm9yOlxyXG4gICAgXCIke3N1YlN0YXRlS2V5fVwiIGNvdWxkIG5vdCBiZSBmb3VuZCBpbiB7XCJ2YWx1ZVwiOiR7SlNPTi5zdHJpbmdpZnkoc3RhdGUudmFsdWUpfX1cclxuICAgIGA7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBOZXN0ZWRLZXlvZjxUID0gdW5rbm93bj4gPSBUIGV4dGVuZHMgb2JqZWN0XHJcbiAgPyBOZXN0ZWRLZXlPZjxUPiB8IFdpdGhQcmVmaXhOdW1iZXI8TmVzdGVkS2V5T2Y8VD4+XHJcbiAgOiBzdHJpbmc7XHJcbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVDaGFuZ2U8VCA9IHVua25vd24sIE9iamVjdFR5cGUgPSB1bmtub3duPiB7XHJcbiAgdHlwZTogXCJhZGRcIiB8IFwiZGVsZXRlXCIgfCBcInVwZGF0ZVwiO1xyXG4gIHByb3BlcnR5OiBzdHJpbmc7IC8vIGVxdWFscyBcInZhbHVlXCIgaWYgdGhlIHdob2xlIHN0YXRlIGlzIGNoYW5nZWRcclxuXHJcbiAgY3VycmVudFBhdGg6IE5lc3RlZEtleW9mPE9iamVjdFR5cGU+OyAvLyBwYXRoIG9mIHRoZSBwcm9wZXJ0eVxyXG4gIGpzb25Qb2ludGVyOiBzdHJpbmc7IC8vIHBhdGggYXMganNvbiBwb2ludGVyIHN5bnRheFxyXG4gIHRhcmdldDogVDsgLy8gdGhlIHRhcmdldCBvYmplY3RcclxuICBwcm94eT86IFByb3h5Q29uc3RydWN0b3I7IC8vIHRoZSBwcm94eSBvZiB0aGUgb2JqZWN0XHJcblxyXG4gIHByZXZpb3VzVmFsdWU/OiBUOyAvLyBtYXkgYmUgdW5kZWZpbmVkIGlmIHRoZSBwcm9wZXJ0eSBpcyBuZXdcclxuICBuZXdWYWx1ZT86IFQ7IC8vIG1heSBiZSB1bmRlZmluZWQgaWYgdGhlIHByb3BlcnR5IGlzIGRlbGV0ZWRcclxufVxyXG4iXX0=